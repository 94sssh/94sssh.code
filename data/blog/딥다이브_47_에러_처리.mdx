---
title: 모던 자바스크립트 Deep Dive - 47. 에러 처리
date: '2024-10-22T00:00:00'
tags: ['javascript', 'book', 'deepdive']
draft: false
summary: 모던 자바스크립트 Deep Dive - 47. 에러 처리
layout: PostSimple
---

## 47.1. 에러 처리의 필요성

에러를 방치하면 프로그램이 강제 종료된다.

## 47.2. try ... catch ... finally 문

`try ... catch ... finally` 문은 에러 처리 코드를 미리 등록해 두고 에러가 발생하면 에러 처리 코드로 점프하는 방식으로, 일반적으로 이 방법을 에러 처리라고 한다.

finally문은 생략할 수 있고, catch도 생략 가능하지만 catch 없는 try는 의미가 없으므로 생략하지 않는다.

```js
try {
  // 실행할 코드(에러 발생 가능성이 있는 코드)
} catch (err) {
  // try에서 에러 발생시 실행
  // try에서 발생한 Error 객체가 전달
} finally {
  // 에러 발생과 상관없이 반드시 한 번 실행
}
```

## 47.3. Error 객체

`Error` 생성자 함수는 에러 객체를 생성한다. 에러 객체는 message 프로퍼티(Error 생성자 함수에 인수로 전달한 에러 메시지)와 stack 프로퍼티(에러를 발생시킨 콜스택의 호출 정보를 나타내는 문자열, 디버깅 목적)를 갖는다.

| 생성자 함수    | 인스턴스                                                                       |
| -------------- | ------------------------------------------------------------------------------ |
| Error          | 일반적 에러 객체                                                               |
| SyntaxError    | 자바스크립트 문법에 맞지 않는 문을 해석할 때 발생하는 에러 객체                |
| ReferenceError | 참조할 수 없는 식별자를 참조했을 때 발생하는 에러 객체                         |
| TypeError      | 피연산자 또는 인수의 데이터 타입이 유효하지 않을 때 발생하는 에러 객체         |
| RangeError     | 숫자값의 허용 범위를 벗어났을 때 발생하는 에러 객체                            |
| URIError       | encodeURI 또는 decodeURI 함수에 부적절한 인수를 전달했을 때 발생하는 에러 객체 |
| EvalError      | eval 함수에서 발생하는 에러 객체                                               |

## 47.4. throw 문

Error 생성자 함수로 에러 객체를 생성한다고 에러가 발생하는 것은 아니다. 에러 객체 생성과 에러 발생은 의미가 다르다. 에러를 발생시키려면 `try` 코드 블록에서 `throw` 문으로 에러 객체를 던져야 한다.

```js
try {
  throw new Error('Error')
} catch (err) {
  console.log(err)
}
```

## 47.5. 에러의 전파

에러는 호출자 방향으로 전파된다. 즉, 콜 스택의 아래 방향(실행 중인 실행 컨텍스트가 푸시되기 직전에 푸시된 실행 컨텍스트 방향)으로 전파된다. throw된 에러를 어디에서라도 캐치하면 프로그램을 강제 종료시키지 않고 코드의 실행 흐름을 복구할 수 있다.

주의할 점은 비동기 함수인 `setTimeout`이나 프로미스 후속 처리 메서드의 콜백 함수는 호출자가 없다는 것이다. 태스크 큐나 마이크로태스크 큐에 일시 저장되었다가 이벤트 루프에 의해 콜 스택으로 푸시되어 실행되기 때문에 콜 스택의 가장 하부에 존재하게 되어 에러를 전파할 호출자가 존재하지 않기 때문.
