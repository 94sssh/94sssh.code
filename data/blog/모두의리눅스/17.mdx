---
title: '[모두의 리눅스] - 19. 버전 관리 시스템'
date: '2025-11-15'
tags: ['linux', 'os', '모두의리눅스']
draft: false
summary: 19. 버전 관리 시스템
layout: PostSimple
---

## 19.3. 기본적인 사용법

`리비전` | `커밋`: 어느 시점에서의 프로젝트 상태

`git commit`시 `-m` 옵션 없이 실행하면 로그 메세지 입력을 위해 에디터가 실행되는데, 에디터를 따로 지정하지 않으면 Vim이 실행됨.

변경 이력 확인시 `git log`를 사용하는데, `-p`옵션을 지정하면 커밋별로 차이점을 같이 표시함.

커밋 오브젝트명 지정 시 커밋이 구별이 가능하면 40글자를 전부 지정하지 않고, 7글자 정도로 지정할 수 있음.

| 명령어     | 내용                  |
| ---------- | --------------------- |
| git init   | 리포지토리 생성       |
| git add    | 커밋 대상으로 등록    |
| git commit | 커밋 수행             |
| git status | 작업 트리의 상태 출력 |
| git diff   | 차이 표시             |
| git log    | 이력 표시             |

## 19.4. 작업 트리와 인덱스

`인덱스`: 파일의 변경 사항을 리포지토리에 반영하기 전 배치하는 영역

`git add`의 역할이 작업 트리에서 인덱스에 파일을 등록하는 것.  
`git diff`로 작업 트리와 인덱스의 차이를 표시할 수 있음.  
`--cached` 옵션을 지정하면 인덱스와 리포지토리의 차이를 출력할 수 있고, `HEAD` 옵션을 지정하면 작업 트리와 리포지토리의 차이를 표시할 수 있음.

## 19.5. 커밋 단위와 인덱스

```bash
$ git add -u # 작업 트리 내 변경한 파일을 전부 인덱스에 등록
$ git add -A # 작업 트리 내 모든 파일을 인덱스에 등록
```

`-u`옵션으로는 새로 작성한 파일은 등록되지 않아 모든 파일을 등록하려면 `-A`를 사용

## 19.6. 실수했을 때 복구하기

### 19.6.1. 커밋하지 않은 변경 사항 복구

```bash
$ git checkout HEAD .
```

파일의 변경 사항이 전부 복원되어 작업 트리와 인덱스가 리포지토리와 동일한 상태가 됨.

### 19.6.2. 잘못된 커밋으로부터 복구

```bash
$ git revert <취소하고 싶은 커밋 오브젝트명>
```

`git revert`를 해도 깃 커밋 이력에서 해당 커밋이 지워지는 것이 아니라, 변경 사항을 복구하는 새로운 커밋이 만들어진다. 이는 변경 사항을 수정하고 수동으로 커밋하는 것과 동일한 작업.

## 19.7. 브랜치

토픽 브랜치: 한 가지 기능을 추가하기 위해 만든 브랜치

## 19.8. 리포지토리의 백업 작성

```bash
git --bare init # 백업용 리포지토리 작성
```

`git init`에 `--bare` 옵션을 지정해 백업용 리포지토리를 만들 수 있음. 관례적으로 디렉터리 이름 끝에는 `.git`을 붙임.

`git push`로 커밋 이력을 전송할 수 있음. `git push <이력을 전달받을 리포지터리> <이력을 보낼 브랜치>:<이력을 전달받을 브랜치>`로 백업용 리포지토리에 현 리포지토리의 브랜치를 보내 백업할 수 있음.

복원할 때는 `git clone` 사용.

## 19.9. 2인 이상의 작업

`git fetch <리포지토리>`를 통해 다른 리포지토리의 이력을 받을 수 있음. 명령어를 실행해도 원격 추적 브랜치가 갱신된 것이고 작업 트리나 로컬 브랜치에는 반영되지 않는데, 가져온 이력을 로컬 브랜치에 반영할 때는 `git merge`를 사용.

`git pull`은 두 명령어를 합친 명령어.
